# LeetCode: 324. 摆动排序 II

[TOC]

## 1、题目描述

给定一个无序的数组 `nums`，将它重新排列成 `nums[0] < nums[1] > nums[2] < nums[3]...` 的顺序。

**示例 1:**

```
输入: nums = [1, 5, 1, 1, 6, 4]
输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]
```

**示例 2:**

```
输入: nums = [1, 3, 2, 2, 3, 1]
输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2]
```

**说明:**
你可以假设所有输入都会得到有效的结果。

**进阶:**
你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？

## 2、解题思路

​	

先排序，然后将数据进行交叉

举个例子，

```
[1, 5, 1, 1, 6, 4]
排序后：
[1, 1, 1, 4, 5, 6]
首先，将前面一半取出来
[1, 1, 1]
取出后面一半
[4, 5, 6]
交错摆放即可
1    1    1
  4     5   6
```

不过，上面的情况，遇到下面的就会出现问题

```
[4, 5, 5, 6]
4   5
  5  6
```

如果遇到相等的情况，就有问题了

因此，我们将它们反过来输出

```
5   4
  6    5
```

这样就得到结果了

```python
class Solution:
    def wiggleSort(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        nums.sort()
        half = math.ceil(len(nums) / 2)
        nums[::2], nums[1::2] = nums[half - 1::-1], nums[len(nums) - 1:half - 1:-1]
```

