# LeetCode: 762. 二进制表示中质数个计算置位

[TOC]



## 1、题目描述



给定两个整数 `L` 和 `R` ，找到闭区间 `[L, R]` 范围内，计算置位位数为质数的整数个数。

（注意，计算置位代表二进制表示中1的个数。例如 `21` 的二进制表示 `10101` 有 3 个计算置位。还有，1 不是质数。）

**示例 1:**

```
输入: L = 6, R = 10
输出: 4
解释:
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)
```

**示例 2:**

```
输入: L = 10, R = 15
输出: 5
解释:
10 -> 1010 (2 个计算置位, 2 是质数)
11 -> 1011 (3 个计算置位, 3 是质数)
12 -> 1100 (2 个计算置位, 2 是质数)
13 -> 1101 (3 个计算置位, 3 是质数)
14 -> 1110 (3 个计算置位, 3 是质数)
15 -> 1111 (4 个计算置位, 4 不是质数)
```

**注意:**

1. `L, R` 是 `L <= R` 且在 `[1, 10^6]` 中的整数。
2. `R - L` 的最大值为 10000。





## 2、解题思路

​	这道题实际上很简单，因为位数最多是32位，其中是质数的有

```
2,3,5,7,11,13,17,19,23,29,31
```

​	直接判断就可以了

​	

​	

```c
int countOneNums(int num) {
    int result = 0;
    for (int i = 0; i < 32; i++) {
        if ((num & (1 << i)) != 0) {
            result++;
        }
    }
    return result;
}

bool isPrime(int i) {

    switch (i) {
        case 2:
        case 3:
        case 5:
        case 7:
        case 11:
        case 13:
        case 17:
        case 19:
        case 23:
        case 29:
        case 31:
            return true;
        default:
            return false;
    }
}


int countPrimeSetBits(int L, int R) {
    int result = 0;
    for (int i = L; i <= R; i++) {
        if (isPrime(countOneNums(i))){
            result++;
        }
    }
    return result;   
}
```



​	当然，质数判断也可以有更简单的方式，直接用32个数的缓冲数组，匹配下标即可

